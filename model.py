# import some require library
from torch.utils.data import Dataset
import numpy as np
from PIL import Image
import os



# Defines a class named CustomImageDataset that inherits from PyTorch's Dataset class.
class CustomImageDataset(Dataset):

    #Initializes the dataset with the root directory where images are stored (root_dir), an optional transformation to be applied to the images (transform), and a boolean flag include_feature_vector which determines whether to include pre-computed feature vectors for the images.
    def __init__(self, root_dir, transform=None, include_feature_vector=True):
        # Stores the root directory where the images are located.
        self.root_dir = root_dir
        # Stores the transformation function to be applied to the images (e.g., resizing, cropping).
        self.transform = transform
        # Contains a sorted list of class names, derived from the subdirectories in the root directory.
        self.classes = sorted(os.listdir(root_dir))
        # Contains a list of tuples, where each tuple consists of a class label and the path to an image file. This list is generated by the _generate_image_list() method.
        self.image_list = self._generate_image_list()
        # Stores a boolean flag indicating whether to include pre-computed feature vectors for the images.
        self.include_feature_vector = include_feature_vector

    # returns the total number of images in the dataset.
    def __len__(self):
        return len(self.image_list)

    # retrieves an item (image and its associated label) from the dataset given its index idx.
    def __getitem__(self, idx):
        
        #1. Extracts the label and image path for the specified index from the image_list.
        label, image_path = self.image_list[idx]
        image_name = os.path.basename(os.path.dirname(image_path))  # Get subcategory name
        
        #2. Use PIL to open the image
        image = Image.open(image_path).convert('RGB')

        #3. Applies the specified transformation (transform) to the image, if provided.
        if self.transform:
            image = self.transform(image)

        #4. Initializes a default feature vector. This will be replaced if include_feature_vector is set to True.
        feature_vector = np.array([[1, 1, 1]])
        
        if self.include_feature_vector:
            #5. Generates the filename and path for the feature vector file associated with the current image
            vector_name = f'{os.path.splitext(os.path.basename(image_path))[0]}_vector.npy'
            vector_path = os.path.join(os.path.dirname(image_path), vector_name)
            #6. Loads the pre-computed feature vector from the corresponding .npy file.
            feature_vector = np.load(vector_path)

        return label, image_name, image, feature_vector

    # def load_feature_vectors(self):
    #     feature_vectors = []
    #     for img_path in self.image_paths:
    #         # Assuming you have a function get_vector that returns the feature vector
    #         feature_vector = get_vector(img_path, your_model, your_layer, your_output_size)
    #         feature_vectors.append(feature_vector)
    #     return feature_vectors

    # create a list of image paths and their associated class labels.
    def _generate_image_list(self):
        image_list = []
        for class_name in self.classes:
            class_path = os.path.join(self.root_dir, class_name)
            for root, _, files in os.walk(class_path):
                for file in files:
                    if file.lower().endswith(('.jpg', '.jpeg', '.png')):
                        image_list.append((class_name, os.path.join(root, file)))
        return image_list

    # process images and save their feature vectors.
    def process_images_and_save_vectors(self, get_vector_func, model, layer, output_size):
        # Iterate over each image in the dataset.
        for idx in range(len(self)):
            # Get the label and image path for the current index.
            _, _, _, _ = self.__getitem__(idx)
            # Extract the image path from image_list for the current index.
            img_path = self.image_list[idx][1]
            # Compute the feature vector for the current image.
            image_feature = get_vector_func(img_path, model, layer, output_size)
            # Save the image feature vector in the same directory with .npy extension
            save_path = os.path.splitext(img_path)[0] + '_vector.npy'
            np.save(save_path, image_feature)
        print("Done")
